; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\hmc5883.o --depend=.\Flash\Obj\hmc5883.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I"D:\KEIL MDK\ARM\INC" -I"D:\KEIL MDK\ARM\INC\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\hmc5883.crf ..\..\User\Modules\Modules_hmc5883\hmc5883.c]
                          THUMB

                          AREA ||i.Init_HMC5883L||, CODE, READONLY, ALIGN=1

                  Init_HMC5883L PROC
;;;25     /*====================================================================================================*/
;;;26     u8 Init_HMC5883L(void)
000000  b538              PUSH     {r3-r5,lr}
;;;27     {
;;;28     	u8 sig = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;29     	u8 ack;  
;;;30     	
;;;31     	ack = i2cRead(MAG_ADDRESS, 0x0A, 1, &sig);
000006  466b              MOV      r3,sp
000008  2201              MOVS     r2,#1
00000a  210a              MOVS     r1,#0xa
00000c  201e              MOVS     r0,#0x1e
00000e  f7fffffe          BL       i2cRead
000012  4604              MOV      r4,r0
;;;32     	
;;;33     	if (!ack || sig != 'H')
000014  b11c              CBZ      r4,|L1.30|
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  2848              CMP      r0,#0x48
00001c  d001              BEQ      |L1.34|
                  |L1.30|
;;;34     			return FALSE;
00001e  2000              MOVS     r0,#0
                  |L1.32|
;;;35     
;;;36     	// leave test mode
;;;37     	i2cWrite(MAG_ADDRESS, HMC58X3_R_CONFA, 0x70);   // Configuration Register A  -- 0 11 100 00  num samples: 8 ; output rate: 15Hz ; normal measurement mode
;;;38     	i2cWrite(MAG_ADDRESS, HMC58X3_R_CONFB, 0x20);   // Configuration Register B  -- 001 00000    configuration gain 1.3Ga
;;;39     	i2cWrite(MAG_ADDRESS, HMC58X3_R_MODE, 0x00);    // Mode register             -- 000000 00    continuous Conversion Mode
;;;40     	delay(100);
;;;41     
;;;42     	return TRUE;	 
;;;43     }
000020  bd38              POP      {r3-r5,pc}
                  |L1.34|
000022  2270              MOVS     r2,#0x70              ;37
000024  2100              MOVS     r1,#0                 ;37
000026  201e              MOVS     r0,#0x1e              ;37
000028  f7fffffe          BL       i2cWrite
00002c  2220              MOVS     r2,#0x20              ;38
00002e  2101              MOVS     r1,#1                 ;38
000030  201e              MOVS     r0,#0x1e              ;38
000032  f7fffffe          BL       i2cWrite
000036  2200              MOVS     r2,#0                 ;39
000038  2102              MOVS     r1,#2                 ;39
00003a  201e              MOVS     r0,#0x1e              ;39
00003c  f7fffffe          BL       i2cWrite
000040  2064              MOVS     r0,#0x64              ;40
000042  f7fffffe          BL       delay
000046  2001              MOVS     r0,#1                 ;42
000048  e7ea              B        |L1.32|
;;;44     	
                          ENDP


                          AREA ||i.hmc5883lRead||, CODE, READONLY, ALIGN=2

                  hmc5883lRead PROC
;;;53     /*====================================================================================================*/
;;;54     void hmc5883lRead(int16_t *magData)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;55     {
000004  4605              MOV      r5,r0
;;;56     	u8 buf[6],cy;
;;;57     	int16_t mag[3];
;;;58     
;;;59     	i2cRead(MAG_ADDRESS, MAG_DATA_REGISTER, 6, buf);
000006  ab02              ADD      r3,sp,#8
000008  2206              MOVS     r2,#6
00000a  2103              MOVS     r1,#3
00000c  201e              MOVS     r0,#0x1e
00000e  f7fffffe          BL       i2cRead
;;;60     
;;;61     	mag[0] = (int16_t)(buf[0] << 8 | buf[1]) ;
000012  f89d0009          LDRB     r0,[sp,#9]
000016  f89d1008          LDRB     r1,[sp,#8]
00001a  ea402001          ORR      r0,r0,r1,LSL #8
00001e  b200              SXTH     r0,r0
000020  f8ad0000          STRH     r0,[sp,#0]
;;;62     	mag[1] = (int16_t)(buf[2] << 8 | buf[3]) ;
000024  f89d000b          LDRB     r0,[sp,#0xb]
000028  f89d100a          LDRB     r1,[sp,#0xa]
00002c  ea402001          ORR      r0,r0,r1,LSL #8
000030  b200              SXTH     r0,r0
000032  f8ad0002          STRH     r0,[sp,#2]
;;;63     	mag[2] = (int16_t)(buf[4] << 8 | buf[5]) ;
000036  f89d000d          LDRB     r0,[sp,#0xd]
00003a  f89d100c          LDRB     r1,[sp,#0xc]
00003e  ea402001          ORR      r0,r0,r1,LSL #8
000042  b200              SXTH     r0,r0
000044  f8ad0004          STRH     r0,[sp,#4]
;;;64     
;;;65     	if(flag.calibratingM)  //需要校准
000048  4824              LDR      r0,|L2.220|
00004a  79c0              LDRB     r0,[r0,#7]  ; flag
00004c  b328              CBZ      r0,|L2.154|
;;;66     	{
;;;67     		for(cy=0;cy<3;cy++){
00004e  2400              MOVS     r4,#0
000050  e021              B        |L2.150|
                  |L2.82|
;;;68     			if(*(mag_limt+cy)> mag[cy]) *(mag_limt+cy) = mag[cy];  //找最小
000052  4823              LDR      r0,|L2.224|
000054  6800              LDR      r0,[r0,#0]  ; mag_limt
000056  f9300014          LDRSH    r0,[r0,r4,LSL #1]
00005a  f93d1014          LDRSH    r1,[sp,r4,LSL #1]
00005e  4288              CMP      r0,r1
000060  dd06              BLE      |L2.112|
000062  f83d0014          LDRH     r0,[sp,r4,LSL #1]
000066  491e              LDR      r1,|L2.224|
000068  6809              LDR      r1,[r1,#0]  ; mag_limt
00006a  f8210014          STRH     r0,[r1,r4,LSL #1]
00006e  e010              B        |L2.146|
                  |L2.112|
;;;69     
;;;70     			else if(*(mag_limt+cy+3)<mag[cy]) *(mag_limt+cy+3) = mag[cy];  //找最大
000070  481b              LDR      r0,|L2.224|
000072  6800              LDR      r0,[r0,#0]  ; mag_limt
000074  eb000044          ADD      r0,r0,r4,LSL #1
000078  f9b00006          LDRSH    r0,[r0,#6]
00007c  f93d1014          LDRSH    r1,[sp,r4,LSL #1]
000080  4288              CMP      r0,r1
000082  da06              BGE      |L2.146|
000084  f83d0014          LDRH     r0,[sp,r4,LSL #1]
000088  4915              LDR      r1,|L2.224|
00008a  6809              LDR      r1,[r1,#0]  ; mag_limt
00008c  eb010144          ADD      r1,r1,r4,LSL #1
000090  80c8              STRH     r0,[r1,#6]
                  |L2.146|
000092  1c60              ADDS     r0,r4,#1              ;67
000094  b2c4              UXTB     r4,r0                 ;67
                  |L2.150|
000096  2c03              CMP      r4,#3                 ;67
000098  dbdb              BLT      |L2.82|
                  |L2.154|
;;;71     		}
;;;72     	}
;;;73     	for(cy=0;cy<3;cy++)
00009a  2400              MOVS     r4,#0
00009c  e01a              B        |L2.212|
                  |L2.158|
;;;74     		*(magData+cy) = (float)(mag[cy] -(*(mag_limt+cy+3) + *(mag_limt+cy))/2);
00009e  4910              LDR      r1,|L2.224|
0000a0  6809              LDR      r1,[r1,#0]  ; mag_limt
0000a2  eb010144          ADD      r1,r1,r4,LSL #1
0000a6  f9b11006          LDRSH    r1,[r1,#6]
0000aa  4a0d              LDR      r2,|L2.224|
0000ac  6812              LDR      r2,[r2,#0]  ; mag_limt
0000ae  f9322014          LDRSH    r2,[r2,r4,LSL #1]
0000b2  188e              ADDS     r6,r1,r2
0000b4  eb0671d6          ADD      r1,r6,r6,LSR #31
0000b8  f93d2014          LDRSH    r2,[sp,r4,LSL #1]
0000bc  eba20061          SUB      r0,r2,r1,ASR #1
0000c0  f7fffffe          BL       __aeabi_i2f
0000c4  4607              MOV      r7,r0
0000c6  f7fffffe          BL       __aeabi_f2iz
0000ca  b200              SXTH     r0,r0
0000cc  f8250014          STRH     r0,[r5,r4,LSL #1]
0000d0  1c60              ADDS     r0,r4,#1              ;73
0000d2  b2c4              UXTB     r4,r0                 ;73
                  |L2.212|
0000d4  2c03              CMP      r4,#3                 ;73
0000d6  dbe2              BLT      |L2.158|
;;;75     }
0000d8  e8bd81ff          POP      {r0-r8,pc}
;;;76     
                          ENDP

                  |L2.220|
                          DCD      flag
                  |L2.224|
                          DCD      mag_limt

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  HMC58X3_limit
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  mag_limt
                          DCD      HMC58X3_limit
