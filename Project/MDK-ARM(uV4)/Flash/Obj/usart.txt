; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\usart.o --depend=.\Flash\Obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I"D:\KEIL MDK\ARM\INC" -I"D:\KEIL MDK\ARM\INC\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\usart.crf ..\..\User\Driver\UART\usart.c]
                          THUMB

                          AREA ||i.UART1_Put_Char||, CODE, READONLY, ALIGN=2

                  UART1_Put_Char PROC
;;;39     *******************************************************************************/
;;;40     uint8_t UART1_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;41     {
000002  4604              MOV      r4,r0
;;;42     	//将要发送的字节写到UART1的发送缓冲区
;;;43     	USART_SendData(USART1, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L1.28|
000008  f7fffffe          BL       USART_SendData
;;;44     	//等待发送完成
;;;45       	while (!(USART1->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L1.14|
00000e  4803              LDR      r0,|L1.28|
000010  8800              LDRH     r0,[r0,#0]
000012  f0100f80          TST      r0,#0x80
000016  d0fa              BEQ      |L1.14|
;;;46     	return DataToSend;
000018  4620              MOV      r0,r4
;;;47     }
00001a  bd10              POP      {r4,pc}
;;;48     
                          ENDP

                  |L1.28|
                          DCD      0x40013800

                          AREA ||i.UART2_Put_Char||, CODE, READONLY, ALIGN=2

                  UART2_Put_Char PROC
;;;243    *******************************************************************************/
;;;244    uint8_t UART2_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246    	//将要发送的字节写到UART1的发送缓冲区
;;;247    	USART_SendData(USART2, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4805              LDR      r0,|L2.28|
000008  f7fffffe          BL       USART_SendData
;;;248    	//等待发送完成
;;;249      	while (!(USART2->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L2.14|
00000e  4803              LDR      r0,|L2.28|
000010  8800              LDRH     r0,[r0,#0]
000012  f0100f80          TST      r0,#0x80
000016  d0fa              BEQ      |L2.14|
;;;250    	return DataToSend;
000018  4620              MOV      r0,r4
;;;251    }
00001a  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  |L2.28|
                          DCD      0x40004400

                          AREA ||i.USART1_printf||, CODE, READONLY, ALIGN=1

                  USART1_printf PROC
;;;137     */
;;;138    void USART1_printf(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;139    {
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
;;;140    	const char *s;
;;;141      int d;   
;;;142      char buf[16];
;;;143    
;;;144      va_list ap;
;;;145      va_start(ap, Data);
000008  a80c              ADD      r0,sp,#0x30
00000a  9001              STR      r0,[sp,#4]
;;;146    
;;;147    	while ( *Data != 0)     // 判断是否到达字符串结束符
00000c  e073              B        |L3.246|
                  |L3.14|
;;;148    	{				                          
;;;149    		if ( *Data == 0x5c )  //'\'
00000e  980b              LDR      r0,[sp,#0x2c]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d11c              BNE      |L3.80|
;;;150    		{									  
;;;151    			switch ( *++Data )
000016  980b              LDR      r0,[sp,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  900b              STR      r0,[sp,#0x2c]
00001c  7800              LDRB     r0,[r0,#0]
00001e  286e              CMP      r0,#0x6e
000020  d009              BEQ      |L3.54|
000022  2872              CMP      r0,#0x72
000024  d10f              BNE      |L3.70|
;;;152    			{
;;;153    				case 'r':							          //回车符
;;;154    					USART_SendData(USARTx, 0x0d);
000026  210d              MOVS     r1,#0xd
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       USART_SendData
;;;155    					Data ++;
00002e  980b              LDR      r0,[sp,#0x2c]
000030  1c40              ADDS     r0,r0,#1
000032  900b              STR      r0,[sp,#0x2c]
;;;156    					break;
000034  e00b              B        |L3.78|
                  |L3.54|
;;;157    
;;;158    				case 'n':							          //换行符
;;;159    					USART_SendData(USARTx, 0x0a);	
000036  210a              MOVS     r1,#0xa
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       USART_SendData
;;;160    					Data ++;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  1c40              ADDS     r0,r0,#1
000042  900b              STR      r0,[sp,#0x2c]
;;;161    					break;
000044  e003              B        |L3.78|
                  |L3.70|
;;;162    				
;;;163    				default:
;;;164    					Data ++;
000046  980b              LDR      r0,[sp,#0x2c]
000048  1c40              ADDS     r0,r0,#1
00004a  900b              STR      r0,[sp,#0x2c]
;;;165    				    break;
00004c  bf00              NOP      
                  |L3.78|
00004e  e04b              B        |L3.232|
                  |L3.80|
;;;166    			}			 
;;;167    		}
;;;168    		else if ( *Data == '%')
000050  980b              LDR      r0,[sp,#0x2c]
000052  7800              LDRB     r0,[r0,#0]
000054  2825              CMP      r0,#0x25
000056  d140              BNE      |L3.218|
;;;169    		{									  //
;;;170    			switch ( *++Data )
000058  980b              LDR      r0,[sp,#0x2c]
00005a  1c40              ADDS     r0,r0,#1
00005c  900b              STR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2864              CMP      r0,#0x64
000062  d018              BEQ      |L3.150|
000064  2873              CMP      r0,#0x73
000066  d133              BNE      |L3.208|
;;;171    			{				
;;;172    				case 's':										  //字符串
;;;173    					s = va_arg(ap, const char *);
000068  9801              LDR      r0,[sp,#4]
00006a  c810              LDM      r0!,{r4}
00006c  9001              STR      r0,[sp,#4]
;;;174              for ( ; *s; s++) 
00006e  e00b              B        |L3.136|
                  |L3.112|
;;;175    					{
;;;176    						USART_SendData(USARTx,*s);
000070  7821              LDRB     r1,[r4,#0]
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       USART_SendData
;;;177    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
000078  bf00              NOP      
                  |L3.122|
00007a  2140              MOVS     r1,#0x40
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L3.122|
000086  1c64              ADDS     r4,r4,#1              ;174
                  |L3.136|
000088  7820              LDRB     r0,[r4,#0]            ;174
00008a  2800              CMP      r0,#0                 ;174
00008c  d1f0              BNE      |L3.112|
;;;178              }
;;;179    					Data++;
00008e  980b              LDR      r0,[sp,#0x2c]
000090  1c40              ADDS     r0,r0,#1
000092  900b              STR      r0,[sp,#0x2c]
;;;180              break;
000094  e020              B        |L3.216|
                  |L3.150|
;;;181    
;;;182            case 'd':										//十进制
;;;183              d = va_arg(ap, int);
000096  9801              LDR      r0,[sp,#4]
000098  c820              LDM      r0!,{r5}
00009a  9001              STR      r0,[sp,#4]
;;;184              itoa(d, buf, 10);
00009c  220a              MOVS     r2,#0xa
00009e  a902              ADD      r1,sp,#8
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       itoa
;;;185              for (s = buf; *s; s++) 
0000a6  ac02              ADD      r4,sp,#8
0000a8  e00b              B        |L3.194|
                  |L3.170|
;;;186    					{
;;;187    						USART_SendData(USARTx,*s);
0000aa  7821              LDRB     r1,[r4,#0]
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       USART_SendData
;;;188    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000b2  bf00              NOP      
                  |L3.180|
0000b4  2140              MOVS     r1,#0x40
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       USART_GetFlagStatus
0000bc  2800              CMP      r0,#0
0000be  d0f9              BEQ      |L3.180|
0000c0  1c64              ADDS     r4,r4,#1              ;185
                  |L3.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;185
0000c4  2800              CMP      r0,#0                 ;185
0000c6  d1f0              BNE      |L3.170|
;;;189              }
;;;190    					Data++;
0000c8  980b              LDR      r0,[sp,#0x2c]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  900b              STR      r0,[sp,#0x2c]
;;;191              break;
0000ce  e003              B        |L3.216|
                  |L3.208|
;;;192    				 default:
;;;193    						Data++;
0000d0  980b              LDR      r0,[sp,#0x2c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900b              STR      r0,[sp,#0x2c]
;;;194    				    break;
0000d6  bf00              NOP      
                  |L3.216|
0000d8  e006              B        |L3.232|
                  |L3.218|
;;;195    			}		 
;;;196    		} /* end of else if */
;;;197    		else USART_SendData(USARTx, *Data++);
0000da  980b              LDR      r0,[sp,#0x2c]
0000dc  f8101b01          LDRB     r1,[r0],#1
0000e0  900b              STR      r0,[sp,#0x2c]
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       USART_SendData
                  |L3.232|
;;;198    		while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000e8  bf00              NOP      
                  |L3.234|
0000ea  2140              MOVS     r1,#0x40
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       USART_GetFlagStatus
0000f2  2800              CMP      r0,#0
0000f4  d0f9              BEQ      |L3.234|
                  |L3.246|
0000f6  980b              LDR      r0,[sp,#0x2c]         ;147
0000f8  7800              LDRB     r0,[r0,#0]            ;147
0000fa  2800              CMP      r0,#0                 ;147
0000fc  d187              BNE      |L3.14|
;;;199    	}
;;;200    }
0000fe  b006              ADD      sp,sp,#0x18
000100  bc70              POP      {r4-r6}
000102  f85dfb14          LDR      pc,[sp],#0x14
;;;201    
                          ENDP


                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;76      */
;;;77     static char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;78     {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;79         int     i, d;
;;;80         int     flag = 0;
000008  2700              MOVS     r7,#0
;;;81         char    *ptr = string;
00000a  4629              MOV      r1,r5
;;;82     
;;;83         /* This implementation only works for decimal numbers. */
;;;84         if (radix != 10)
00000c  2e0a              CMP      r6,#0xa
00000e  d003              BEQ      |L4.24|
;;;85         {
;;;86             *ptr = 0;
000010  2000              MOVS     r0,#0
000012  7008              STRB     r0,[r1,#0]
;;;87             return string;
000014  4628              MOV      r0,r5
                  |L4.22|
;;;88         }
;;;89     
;;;90         if (!value)
;;;91         {
;;;92             *ptr++ = 0x30;
;;;93             *ptr = 0;
;;;94             return string;
;;;95         }
;;;96     
;;;97         /* if this is a negative value insert the minus sign. */
;;;98         if (value < 0)
;;;99         {
;;;100            *ptr++ = '-';
;;;101    
;;;102            /* Make the value positive. */
;;;103            value *= -1;
;;;104        }
;;;105    
;;;106        for (i = 10000; i > 0; i /= 10)
;;;107        {
;;;108            d = value / i;
;;;109    
;;;110            if (d || flag)
;;;111            {
;;;112                *ptr++ = (char)(d + 0x30);
;;;113                value -= (d * i);
;;;114                flag = 1;
;;;115            }
;;;116        }
;;;117    
;;;118        /* Null terminate the string. */
;;;119        *ptr = 0;
;;;120    
;;;121        return string;
;;;122    
;;;123    } /* NCL_Itoa */
000016  bdf0              POP      {r4-r7,pc}
                  |L4.24|
000018  b933              CBNZ     r3,|L4.40|
00001a  2030              MOVS     r0,#0x30              ;92
00001c  f8010b01          STRB     r0,[r1],#1            ;92
000020  2000              MOVS     r0,#0                 ;93
000022  7008              STRB     r0,[r1,#0]            ;93
000024  4628              MOV      r0,r5                 ;94
000026  e7f6              B        |L4.22|
                  |L4.40|
000028  2b00              CMP      r3,#0                 ;98
00002a  da03              BGE      |L4.52|
00002c  202d              MOVS     r0,#0x2d              ;100
00002e  f8010b01          STRB     r0,[r1],#1            ;100
000032  425b              RSBS     r3,r3,#0              ;103
                  |L4.52|
000034  f2427210          MOV      r2,#0x2710            ;106
000038  e00d              B        |L4.86|
                  |L4.58|
00003a  fb93f4f2          SDIV     r4,r3,r2              ;108
00003e  b904              CBNZ     r4,|L4.66|
000040  b137              CBZ      r7,|L4.80|
                  |L4.66|
000042  f1040030          ADD      r0,r4,#0x30           ;112
000046  f8010b01          STRB     r0,[r1],#1            ;112
00004a  fb043312          MLS      r3,r4,r2,r3           ;113
00004e  2701              MOVS     r7,#1                 ;114
                  |L4.80|
000050  200a              MOVS     r0,#0xa               ;106
000052  fb92f2f0          SDIV     r2,r2,r0              ;106
                  |L4.86|
000056  2a00              CMP      r2,#0                 ;106
000058  dcef              BGT      |L4.58|
00005a  2000              MOVS     r0,#0                 ;119
00005c  7008              STRB     r0,[r1,#0]            ;119
00005e  4628              MOV      r0,r5                 ;121
000060  e7d9              B        |L4.22|
;;;124    
                          ENDP


                          AREA ||i.usart1_config||, CODE, READONLY, ALIGN=2

                  usart1_config PROC
;;;3      
;;;4      void usart1_config(void)
000000  b500              PUSH     {lr}
;;;5      {
000002  b085              SUB      sp,sp,#0x14
;;;6      	GPIO_InitTypeDef GPIO_InitStructure;
;;;7      	USART_InitTypeDef USART_InitStructure;
;;;8      	
;;;9      	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440004          MOV      r0,#0x4004
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;10     	
;;;11     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00000e  f44f7000          MOV      r0,#0x200
000012  f8ad0010          STRH     r0,[sp,#0x10]
;;;12     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000016  2018              MOVS     r0,#0x18
000018  f88d0013          STRB     r0,[sp,#0x13]
;;;13     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0012          STRB     r0,[sp,#0x12]
;;;14     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  a904              ADD      r1,sp,#0x10
000024  4816              LDR      r0,|L5.128|
000026  f7fffffe          BL       GPIO_Init
;;;15     	
;;;16     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00002a  f44f6080          MOV      r0,#0x400
00002e  f8ad0010          STRH     r0,[sp,#0x10]
;;;17     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000032  2004              MOVS     r0,#4
000034  f88d0013          STRB     r0,[sp,#0x13]
;;;18     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000038  a904              ADD      r1,sp,#0x10
00003a  4811              LDR      r0,|L5.128|
00003c  f7fffffe          BL       GPIO_Init
;;;19     	
;;;20     	  USART_InitStructure.USART_BaudRate = 115200;                 /*设置波特率为115200*/
000040  f44f30e1          MOV      r0,#0x1c200
000044  9000              STR      r0,[sp,#0]
;;;21         USART_InitStructure.USART_WordLength = USART_WordLength_8b;  /*设置数据位为8位*/
000046  2000              MOVS     r0,#0
000048  f8ad0004          STRH     r0,[sp,#4]
;;;22         USART_InitStructure.USART_StopBits = USART_StopBits_1;       /*设置停止位为1位*/
00004c  f8ad0006          STRH     r0,[sp,#6]
;;;23         USART_InitStructure.USART_Parity = USART_Parity_No;          /*无奇偶校验*/    
000050  f8ad0008          STRH     r0,[sp,#8]
;;;24         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; /*没有硬件流控*/
000054  f8ad000c          STRH     r0,[sp,#0xc]
;;;25         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;      /*发送与接收*/
000058  200c              MOVS     r0,#0xc
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;26         /*完成串口COM1的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;27     	
;;;28     	USART_Init(USART1, &USART_InitStructure);
00005e  4669              MOV      r1,sp
000060  4808              LDR      r0,|L5.132|
000062  f7fffffe          BL       USART_Init
;;;29     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2405125          MOV      r1,#0x525
00006c  4805              LDR      r0,|L5.132|
00006e  f7fffffe          BL       USART_ITConfig
;;;30     	USART_Cmd(USART1, ENABLE);
000072  2101              MOVS     r1,#1
000074  4803              LDR      r0,|L5.132|
000076  f7fffffe          BL       USART_Cmd
;;;31     }
00007a  b005              ADD      sp,sp,#0x14
00007c  bd00              POP      {pc}
;;;32     
                          ENDP

00007e  0000              DCW      0x0000
                  |L5.128|
                          DCD      0x40010800
                  |L5.132|
                          DCD      0x40013800

                          AREA ||i.usart2_config||, CODE, READONLY, ALIGN=2

                  usart2_config PROC
;;;201    
;;;202    void usart2_config(void)
000000  b500              PUSH     {lr}
;;;203    {
000002  b085              SUB      sp,sp,#0x14
;;;204    	GPIO_InitTypeDef GPIO_InitStructure;
;;;205    	USART_InitTypeDef USART_InitStructure;
;;;206    	
;;;207    		/* config USART2 clock */
;;;208    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
000004  2101              MOVS     r1,#1
000006  2020              MOVS     r0,#0x20
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;209    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;210      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);  //使能AFIO功能的时钟
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;211      GPIO_PinRemapConfig(GPIO_Remap_USART2 ,ENABLE);  //进行重映射
00001c  2101              MOVS     r1,#1
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       GPIO_PinRemapConfig
;;;212    	
;;;213    	
;;;214      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000024  2020              MOVS     r0,#0x20
000026  f8ad0010          STRH     r0,[sp,#0x10]
;;;215      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00002a  2018              MOVS     r0,#0x18
00002c  f88d0013          STRB     r0,[sp,#0x13]
;;;216      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0012          STRB     r0,[sp,#0x12]
;;;217      GPIO_Init(GPIOD, &GPIO_InitStructure);
000036  a904              ADD      r1,sp,#0x10
000038  4815              LDR      r0,|L6.144|
00003a  f7fffffe          BL       GPIO_Init
;;;218    	    
;;;219      /* Configure USART2 Rx (PD.09) as input floating */
;;;220      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00003e  2040              MOVS     r0,#0x40
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;221      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000044  2004              MOVS     r0,#4
000046  f88d0013          STRB     r0,[sp,#0x13]
;;;222      GPIO_Init(GPIOD, &GPIO_InitStructure);
00004a  a904              ADD      r1,sp,#0x10
00004c  4810              LDR      r0,|L6.144|
00004e  f7fffffe          BL       GPIO_Init
;;;223    	
;;;224    	  USART_InitStructure.USART_BaudRate = 9600;                 /*设置波特率为115200*/
000052  f44f5016          MOV      r0,#0x2580
000056  9000              STR      r0,[sp,#0]
;;;225        USART_InitStructure.USART_WordLength = USART_WordLength_8b;  /*设置数据位为8位*/
000058  2000              MOVS     r0,#0
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;226        USART_InitStructure.USART_StopBits = USART_StopBits_1;       /*设置停止位为1位*/
00005e  f8ad0006          STRH     r0,[sp,#6]
;;;227        USART_InitStructure.USART_Parity = USART_Parity_No;          /*无奇偶校验*/    
000062  f8ad0008          STRH     r0,[sp,#8]
;;;228        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; /*没有硬件流控*/
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;229        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;      /*发送与接收*/
00006a  200c              MOVS     r0,#0xc
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;230        /*完成串口COM3的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;231    	
;;;232    	USART_Init(USART2, &USART_InitStructure);
000070  4669              MOV      r1,sp
000072  4808              LDR      r0,|L6.148|
000074  f7fffffe          BL       USART_Init
;;;233    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000078  2201              MOVS     r2,#1
00007a  f2405125          MOV      r1,#0x525
00007e  4805              LDR      r0,|L6.148|
000080  f7fffffe          BL       USART_ITConfig
;;;234    	USART_Cmd(USART2, ENABLE);
000084  2101              MOVS     r1,#1
000086  4803              LDR      r0,|L6.148|
000088  f7fffffe          BL       USART_Cmd
;;;235    }
00008c  b005              ADD      sp,sp,#0x14
00008e  bd00              POP      {pc}
;;;236    
                          ENDP

                  |L6.144|
                          DCD      0x40011400
                  |L6.148|
                          DCD      0x40004400
