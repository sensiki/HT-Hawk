; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\i2c.o --depend=.\Flash\Obj\i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I"D:\KEIL MDK\ARM\INC" -I"D:\KEIL MDK\ARM\INC\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\i2c.crf ..\..\User\Driver\IIC\I2C.c]
                          THUMB

                          AREA ||i.I2C_Ack||, CODE, READONLY, ALIGN=2

                  I2C_Ack PROC
;;;100    ****************************************************************************** */
;;;101    void I2C_Ack(void)
000000  b500              PUSH     {lr}
;;;102    {	
;;;103    	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  490c              LDR      r1,|L1.56|
000008  6008              STR      r0,[r1,#0]
;;;104    	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;105    	SDA_L;
00000e  f44f6000          MOV      r0,#0x800
000012  490a              LDR      r1,|L1.60|
000014  f8c10c14          STR      r0,[r1,#0xc14]
;;;106    	I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;107    	SCL_H;
00001c  f44f6080          MOV      r0,#0x400
000020  4907              LDR      r1,|L1.64|
000022  6008              STR      r0,[r1,#0]
;;;108    	I2C_delay();
000024  f7fffffe          BL       I2C_delay
;;;109    	SCL_L;
000028  f44f6080          MOV      r0,#0x400
00002c  4903              LDR      r1,|L1.60|
00002e  f8c10c14          STR      r0,[r1,#0xc14]
;;;110    	I2C_delay();
000032  f7fffffe          BL       I2C_delay
;;;111    }   
000036  bd00              POP      {pc}
;;;112    /*******************************************************************************
                          ENDP

                  |L1.56|
                          DCD      0x40010c14
                  |L1.60|
                          DCD      0x40010000
                  |L1.64|
                          DCD      0x40010c10

                          AREA ||i.I2C_INIT||, CODE, READONLY, ALIGN=2

                  I2C_INIT PROC
;;;18     ****************************************************************************** */
;;;19     void I2C_INIT(void)
000000  b508              PUSH     {r3,lr}
;;;20     {
;;;21       GPIO_InitTypeDef  GPIO_InitStructure; 
;;;22      
;;;23     	RCC_APB2PeriphClockCmd(RCC_GPIO_I2C, ENABLE);  //使能GPIOB时钟
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;24       
;;;25     	GPIO_InitStructure.GPIO_Pin =  SCL_PIN;
00000a  f44f6080          MOV      r0,#0x400
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;26       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;27       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  
000018  2014              MOVS     r0,#0x14
00001a  f88d0003          STRB     r0,[sp,#3]
;;;28       GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4808              LDR      r0,|L2.68|
000022  f7fffffe          BL       GPIO_Init
;;;29     
;;;30       GPIO_InitStructure.GPIO_Pin =  SDA_PIN;
000026  f44f6000          MOV      r0,#0x800
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;31       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0002          STRB     r0,[sp,#2]
;;;32       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000034  2014              MOVS     r0,#0x14
000036  f88d0003          STRB     r0,[sp,#3]
;;;33       GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4801              LDR      r0,|L2.68|
00003e  f7fffffe          BL       GPIO_Init
;;;34     }
000042  bd08              POP      {r3,pc}
;;;35     /*******************************************************************************
                          ENDP

                  |L2.68|
                          DCD      0x40010c00

                          AREA ||i.I2C_NoAck||, CODE, READONLY, ALIGN=2

                  I2C_NoAck PROC
;;;118    ****************************************************************************** */
;;;119    void I2C_NoAck(void)
000000  b500              PUSH     {lr}
;;;120    {	
;;;121    	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  490c              LDR      r1,|L3.56|
000008  6008              STR      r0,[r1,#0]
;;;122    	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;123    	SDA_H;
00000e  f44f6000          MOV      r0,#0x800
000012  490a              LDR      r1,|L3.60|
000014  f8c10c10          STR      r0,[r1,#0xc10]
;;;124    	I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;125    	SCL_H;
00001c  f44f6080          MOV      r0,#0x400
000020  4907              LDR      r1,|L3.64|
000022  6008              STR      r0,[r1,#0]
;;;126    	I2C_delay();
000024  f7fffffe          BL       I2C_delay
;;;127    	SCL_L;
000028  f44f6080          MOV      r0,#0x400
00002c  4903              LDR      r1,|L3.60|
00002e  f8c10c14          STR      r0,[r1,#0xc14]
;;;128    	I2C_delay();
000032  f7fffffe          BL       I2C_delay
;;;129    } 
000036  bd00              POP      {pc}
;;;130    /*******************************************************************************
                          ENDP

                  |L3.56|
                          DCD      0x40010c14
                  |L3.60|
                          DCD      0x40010000
                  |L3.64|
                          DCD      0x40010c10

                          AREA ||i.I2C_RadeByte||, CODE, READONLY, ALIGN=2

                  I2C_RadeByte PROC
;;;186    ****************************************************************************** */
;;;187    unsigned char I2C_RadeByte(void)  //数据从高位到低位//
000000  b500              PUSH     {lr}
;;;188    { 
;;;189        u8 i=8;
000002  2108              MOVS     r1,#8
;;;190        u8 ReceiveByte=0;
000004  2000              MOVS     r0,#0
;;;191    
;;;192        SDA_H;				
000006  020a              LSLS     r2,r1,#8
000008  4b11              LDR      r3,|L4.80|
00000a  601a              STR      r2,[r3,#0]
;;;193        while(i--)
00000c  e015              B        |L4.58|
                  |L4.14|
;;;194        {
;;;195          ReceiveByte<<=1;      
00000e  0642              LSLS     r2,r0,#25
000010  0e10              LSRS     r0,r2,#24
;;;196          SCL_L;
000012  f44f6280          MOV      r2,#0x400
000016  4b0f              LDR      r3,|L4.84|
000018  601a              STR      r2,[r3,#0]
;;;197          I2C_delay();
00001a  f7fffffe          BL       I2C_delay
;;;198    	  SCL_H;
00001e  f44f6280          MOV      r2,#0x400
000022  4b0d              LDR      r3,|L4.88|
000024  f8c32c10          STR      r2,[r3,#0xc10]
;;;199          I2C_delay();	
000028  f7fffffe          BL       I2C_delay
;;;200          if(SDA_read)
00002c  4a0b              LDR      r2,|L4.92|
00002e  6812              LDR      r2,[r2,#0]
000030  f4126f00          TST      r2,#0x800
000034  d001              BEQ      |L4.58|
;;;201          {
;;;202            ReceiveByte|=0x01;
000036  f0400001          ORR      r0,r0,#1
                  |L4.58|
00003a  000a              MOVS     r2,r1                 ;193
00003c  f1a10301          SUB      r3,r1,#1              ;193
000040  b2d9              UXTB     r1,r3                 ;193
000042  d1e4              BNE      |L4.14|
;;;203          }
;;;204        }
;;;205        SCL_L;
000044  f44f6280          MOV      r2,#0x400
000048  4b02              LDR      r3,|L4.84|
00004a  601a              STR      r2,[r3,#0]
;;;206        return ReceiveByte;
;;;207    } 
00004c  bd00              POP      {pc}
;;;208    //ZRX          
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      0x40010c10
                  |L4.84|
                          DCD      0x40010c14
                  |L4.88|
                          DCD      0x40010000
                  |L4.92|
                          DCD      0x40010c08

                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=2

                  I2C_SendByte PROC
;;;161    ****************************************************************************** */
;;;162    void I2C_SendByte(unsigned char SendByte) //数据从高位到低位//
000000  b500              PUSH     {lr}
;;;163    {
;;;164        u8 i=8;
000002  2108              MOVS     r1,#8
;;;165        while(i--)
000004  e01b              B        |L5.62|
                  |L5.6|
;;;166        {
;;;167            SCL_L;
000006  f44f6280          MOV      r2,#0x400
00000a  4b12              LDR      r3,|L5.84|
00000c  601a              STR      r2,[r3,#0]
;;;168            I2C_delay();
00000e  f7fffffe          BL       I2C_delay
;;;169          if(SendByte&0x80)
000012  f0100f80          TST      r0,#0x80
000016  d004              BEQ      |L5.34|
;;;170            SDA_H;  
000018  f44f6200          MOV      r2,#0x800
00001c  4b0e              LDR      r3,|L5.88|
00001e  601a              STR      r2,[r3,#0]
000020  e003              B        |L5.42|
                  |L5.34|
;;;171          else 
;;;172            SDA_L;   
000022  f44f6200          MOV      r2,#0x800
000026  4b0b              LDR      r3,|L5.84|
000028  601a              STR      r2,[r3,#0]
                  |L5.42|
;;;173            SendByte<<=1;
00002a  0642              LSLS     r2,r0,#25
00002c  0e10              LSRS     r0,r2,#24
;;;174            I2C_delay();
00002e  f7fffffe          BL       I2C_delay
;;;175    		SCL_H;
000032  f44f6280          MOV      r2,#0x400
000036  4b08              LDR      r3,|L5.88|
000038  601a              STR      r2,[r3,#0]
;;;176            I2C_delay();
00003a  f7fffffe          BL       I2C_delay
                  |L5.62|
00003e  000a              MOVS     r2,r1                 ;165
000040  f1a10301          SUB      r3,r1,#1              ;165
000044  b2d9              UXTB     r1,r3                 ;165
000046  d1de              BNE      |L5.6|
;;;177        }
;;;178        SCL_L;
000048  f44f6280          MOV      r2,#0x400
00004c  4b01              LDR      r3,|L5.84|
00004e  601a              STR      r2,[r3,#0]
;;;179    }  
000050  bd00              POP      {pc}
;;;180    /*******************************************************************************
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      0x40010c14
                  |L5.88|
                          DCD      0x40010c10

                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=2

                  I2C_Start PROC
;;;62     ****************************************************************************** */
;;;63     uint16_t I2C_Start(void)
000000  b500              PUSH     {lr}
;;;64     {
;;;65     	SDA_H;
000002  f44f6000          MOV      r0,#0x800
000006  4915              LDR      r1,|L6.92|
000008  6008              STR      r0,[r1,#0]
;;;66     	SCL_H;
00000a  f44f6080          MOV      r0,#0x400
00000e  4914              LDR      r1,|L6.96|
000010  f8c10c10          STR      r0,[r1,#0xc10]
;;;67     	I2C_delay();
000014  f7fffffe          BL       I2C_delay
;;;68     	if(!SDA_read)return FALSE;	//SDA线为低电平则总线忙,退出
000018  4812              LDR      r0,|L6.100|
00001a  6800              LDR      r0,[r0,#0]
00001c  b908              CBNZ     r0,|L6.34|
00001e  2001              MOVS     r0,#1
000020  e000              B        |L6.36|
                  |L6.34|
000022  2000              MOVS     r0,#0
                  |L6.36|
000024  f4106f00          TST      r0,#0x800
000028  d001              BEQ      |L6.46|
00002a  2000              MOVS     r0,#0
                  |L6.44|
;;;69     	SDA_L;
;;;70     	I2C_delay();
;;;71     	if(SDA_read) return FALSE;	//SDA线为高电平则总线出错,退出
;;;72     	SDA_L;
;;;73     	I2C_delay();
;;;74     	return TRUE;
;;;75     }
00002c  bd00              POP      {pc}
                  |L6.46|
00002e  f44f6000          MOV      r0,#0x800             ;69
000032  490d              LDR      r1,|L6.104|
000034  6008              STR      r0,[r1,#0]            ;69
000036  f7fffffe          BL       I2C_delay
00003a  4809              LDR      r0,|L6.96|
00003c  f8d00c08          LDR      r0,[r0,#0xc08]        ;71
000040  f4106f00          TST      r0,#0x800             ;71
000044  d001              BEQ      |L6.74|
000046  2000              MOVS     r0,#0                 ;71
000048  e7f0              B        |L6.44|
                  |L6.74|
00004a  f44f6000          MOV      r0,#0x800             ;72
00004e  4906              LDR      r1,|L6.104|
000050  6008              STR      r0,[r1,#0]            ;72
000052  f7fffffe          BL       I2C_delay
000056  2001              MOVS     r0,#1                 ;74
000058  e7e8              B        |L6.44|
;;;76     /*******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
                          DCD      0x40010c10
                  |L6.96|
                          DCD      0x40010000
                  |L6.100|
                          DCD      0x40010c08
                  |L6.104|
                          DCD      0x40010c14

                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=2

                  I2C_Stop PROC
;;;82     ****************************************************************************** */
;;;83     void I2C_Stop(void)
000000  b500              PUSH     {lr}
;;;84     {
;;;85     	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  490c              LDR      r1,|L7.56|
000008  6008              STR      r0,[r1,#0]
;;;86     	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;87     	SDA_L;
00000e  f44f6000          MOV      r0,#0x800
000012  490a              LDR      r1,|L7.60|
000014  f8c10c14          STR      r0,[r1,#0xc14]
;;;88     	I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;89     	SCL_H;
00001c  f44f6080          MOV      r0,#0x400
000020  4907              LDR      r1,|L7.64|
000022  6008              STR      r0,[r1,#0]
;;;90     	I2C_delay();
000024  f7fffffe          BL       I2C_delay
;;;91     	SDA_H;
000028  f44f6000          MOV      r0,#0x800
00002c  4903              LDR      r1,|L7.60|
00002e  f8c10c10          STR      r0,[r1,#0xc10]
;;;92     	I2C_delay();
000032  f7fffffe          BL       I2C_delay
;;;93     } 
000036  bd00              POP      {pc}
;;;94     /*******************************************************************************
                          ENDP

                  |L7.56|
                          DCD      0x40010c14
                  |L7.60|
                          DCD      0x40010000
                  |L7.64|
                          DCD      0x40010c10

                          AREA ||i.I2C_WaitAck||, CODE, READONLY, ALIGN=2

                  I2C_WaitAck PROC
;;;136    ****************************************************************************** */
;;;137    uint16_t I2C_WaitAck(void) 	 //返回为:=1有ACK,=0无ACK
000000  b500              PUSH     {lr}
;;;138    {
;;;139    	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  4913              LDR      r1,|L8.84|
000008  6008              STR      r0,[r1,#0]
;;;140    	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;141    	SDA_H;			
00000e  f44f6000          MOV      r0,#0x800
000012  4911              LDR      r1,|L8.88|
000014  f8c10c10          STR      r0,[r1,#0xc10]
;;;142    	I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;143    	SCL_H;
00001c  f44f6080          MOV      r0,#0x400
000020  490e              LDR      r1,|L8.92|
000022  6008              STR      r0,[r1,#0]
;;;144    	I2C_delay();
000024  f7fffffe          BL       I2C_delay
;;;145    	if(SDA_read)
000028  480b              LDR      r0,|L8.88|
00002a  f8d00c08          LDR      r0,[r0,#0xc08]
00002e  f4106f00          TST      r0,#0x800
000032  d007              BEQ      |L8.68|
;;;146    	{
;;;147          SCL_L;
000034  f44f6080          MOV      r0,#0x400
000038  4906              LDR      r1,|L8.84|
00003a  6008              STR      r0,[r1,#0]
;;;148    	  I2C_delay();
00003c  f7fffffe          BL       I2C_delay
;;;149          return FALSE;
000040  2000              MOVS     r0,#0
                  |L8.66|
;;;150    	}
;;;151    	SCL_L;
;;;152    	I2C_delay();
;;;153    	return TRUE;
;;;154    }
000042  bd00              POP      {pc}
                  |L8.68|
000044  f44f6080          MOV      r0,#0x400             ;151
000048  4902              LDR      r1,|L8.84|
00004a  6008              STR      r0,[r1,#0]            ;151
00004c  f7fffffe          BL       I2C_delay
000050  2001              MOVS     r0,#1                 ;153
000052  e7f6              B        |L8.66|
;;;155    /*******************************************************************************
                          ENDP

                  |L8.84|
                          DCD      0x40010c14
                  |L8.88|
                          DCD      0x40010000
                  |L8.92|
                          DCD      0x40010c10

                          AREA ||i.I2C_delay||, CODE, READONLY, ALIGN=1

                  I2C_delay PROC
;;;41     ****************************************************************************** */
;;;42     void I2C_delay(void)
000000  bf00              NOP      
;;;43     {
;;;44     	__NOP();
;;;45     }
000002  4770              BX       lr
;;;46     
                          ENDP


                          AREA ||i.Single_Read||, CODE, READONLY, ALIGN=1

                  Single_Read PROC
;;;237    //单字节读取*****************************************
;;;238    unsigned char Single_Read(unsigned char SlaveAddress,unsigned char REG_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;240    	unsigned char REG_data;     	
;;;241    	if(!I2C_Start())return FALSE;
000006  f7fffffe          BL       I2C_Start
00000a  b908              CBNZ     r0,|L10.16|
00000c  2000              MOVS     r0,#0
                  |L10.14|
;;;242        I2C_SendByte(SlaveAddress); //I2C_SendByte(((REG_Address & 0x0700) >>7) | REG_Address & 0xFFFE);//设置高起始地址+器件地址 
;;;243        if(!I2C_WaitAck()){I2C_Stop();return FALSE;}
;;;244        I2C_SendByte((u8) REG_Address);   //设置低起始地址      
;;;245        I2C_WaitAck();
;;;246        I2C_Start();
;;;247        I2C_SendByte(SlaveAddress+1);
;;;248        I2C_WaitAck();
;;;249    
;;;250    	  REG_data= I2C_RadeByte();
;;;251        I2C_NoAck();
;;;252        I2C_Stop();
;;;253        //return TRUE;
;;;254    	return REG_data;
;;;255    }	
00000e  bd70              POP      {r4-r6,pc}
                  |L10.16|
000010  4620              MOV      r0,r4                 ;242
000012  f7fffffe          BL       I2C_SendByte
000016  f7fffffe          BL       I2C_WaitAck
00001a  b918              CBNZ     r0,|L10.36|
00001c  f7fffffe          BL       I2C_Stop
000020  2000              MOVS     r0,#0                 ;243
000022  e7f4              B        |L10.14|
                  |L10.36|
000024  4628              MOV      r0,r5                 ;244
000026  f7fffffe          BL       I2C_SendByte
00002a  f7fffffe          BL       I2C_WaitAck
00002e  f7fffffe          BL       I2C_Start
000032  1c60              ADDS     r0,r4,#1              ;247
000034  b2c0              UXTB     r0,r0                 ;247
000036  f7fffffe          BL       I2C_SendByte
00003a  f7fffffe          BL       I2C_WaitAck
00003e  f7fffffe          BL       I2C_RadeByte
000042  4606              MOV      r6,r0                 ;250
000044  f7fffffe          BL       I2C_NoAck
000048  f7fffffe          BL       I2C_Stop
00004c  4630              MOV      r0,r6                 ;254
00004e  e7de              B        |L10.14|
;;;256    
                          ENDP


                          AREA ||i.Single_Write||, CODE, READONLY, ALIGN=1

                  Single_Write PROC
;;;210    
;;;211    uint16_t Single_Write(unsigned char SlaveAddress,unsigned char REG_Address,unsigned char REG_data)		     //void
000000  b570              PUSH     {r4-r6,lr}
;;;212    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;213      	if(!I2C_Start())return FALSE;
000008  f7fffffe          BL       I2C_Start
00000c  b908              CBNZ     r0,|L11.18|
00000e  2000              MOVS     r0,#0
                  |L11.16|
;;;214        I2C_SendByte(SlaveAddress);   //发送设备地址+写信号//I2C_SendByte(((REG_Address & 0x0700) >>7) | SlaveAddress & 0xFFFE);//设置高起始地址+器件地址 
;;;215        if(!I2C_WaitAck()){I2C_Stop(); return FALSE;}
;;;216        I2C_SendByte(REG_Address );   //设置低起始地址      
;;;217        I2C_WaitAck();	
;;;218        I2C_SendByte(REG_data);
;;;219        I2C_WaitAck();   
;;;220        I2C_Stop(); 
;;;221        delay5ms();
;;;222        return TRUE;
;;;223    }
000010  bd70              POP      {r4-r6,pc}
                  |L11.18|
000012  4630              MOV      r0,r6                 ;214
000014  f7fffffe          BL       I2C_SendByte
000018  f7fffffe          BL       I2C_WaitAck
00001c  b918              CBNZ     r0,|L11.38|
00001e  f7fffffe          BL       I2C_Stop
000022  2000              MOVS     r0,#0                 ;215
000024  e7f4              B        |L11.16|
                  |L11.38|
000026  4620              MOV      r0,r4                 ;216
000028  f7fffffe          BL       I2C_SendByte
00002c  f7fffffe          BL       I2C_WaitAck
000030  4628              MOV      r0,r5                 ;218
000032  f7fffffe          BL       I2C_SendByte
000036  f7fffffe          BL       I2C_WaitAck
00003a  f7fffffe          BL       I2C_Stop
00003e  f7fffffe          BL       delay5ms
000042  2001              MOVS     r0,#1                 ;222
000044  e7e4              B        |L11.16|
;;;224    
                          ENDP


                          AREA ||i.Single_Write_MS5611||, CODE, READONLY, ALIGN=1

                  Single_Write_MS5611 PROC
;;;224    
;;;225    uint16_t Single_Write_MS5611(unsigned char SlaveAddress,unsigned char REG_Address)		     //void
000000  b530              PUSH     {r4,r5,lr}
;;;226    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;227      	if(!I2C_Start())return FALSE;
000006  f7fffffe          BL       I2C_Start
00000a  b908              CBNZ     r0,|L12.16|
00000c  2000              MOVS     r0,#0
                  |L12.14|
;;;228        I2C_SendByte(SlaveAddress);   //发送设备地址+写信号//I2C_SendByte(((REG_Address & 0x0700) >>7) | SlaveAddress & 0xFFFE);//设置高起始地址+器件地址 
;;;229        if(!I2C_WaitAck()){I2C_Stop(); return FALSE;}
;;;230        I2C_SendByte(REG_Address );   //设置低起始地址      
;;;231        I2C_WaitAck();	 
;;;232        I2C_Stop(); 
;;;233        delay5ms();
;;;234        return TRUE;
;;;235    }
00000e  bd30              POP      {r4,r5,pc}
                  |L12.16|
000010  4628              MOV      r0,r5                 ;228
000012  f7fffffe          BL       I2C_SendByte
000016  f7fffffe          BL       I2C_WaitAck
00001a  b918              CBNZ     r0,|L12.36|
00001c  f7fffffe          BL       I2C_Stop
000020  2000              MOVS     r0,#0                 ;229
000022  e7f4              B        |L12.14|
                  |L12.36|
000024  4620              MOV      r0,r4                 ;230
000026  f7fffffe          BL       I2C_SendByte
00002a  f7fffffe          BL       I2C_WaitAck
00002e  f7fffffe          BL       I2C_Stop
000032  f7fffffe          BL       delay5ms
000036  2001              MOVS     r0,#1                 ;234
000038  e7e9              B        |L12.14|
;;;236    
                          ENDP


                          AREA ||i.delay5ms||, CODE, READONLY, ALIGN=1

                  delay5ms PROC
;;;46     
;;;47     void delay5ms(void)
000000  f2413088          MOV      r0,#0x1388
;;;48     {
;;;49     		
;;;50        int i=5000;  
;;;51        while(i) 
000004  e000              B        |L13.8|
                  |L13.6|
;;;52        { 
;;;53          i--; 
000006  1e40              SUBS     r0,r0,#1
                  |L13.8|
000008  2800              CMP      r0,#0                 ;51
00000a  d1fc              BNE      |L13.6|
;;;54        }  
;;;55     }
00000c  4770              BX       lr
;;;56     /*******************************************************************************
                          ENDP

