; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -o.\Flash\Obj\stm32f10x_it.o --depend=.\Flash\Obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I"D:\KEIL MDK\ARM\INC" -I"D:\KEIL MDK\ARM\INC\ST\STM32F10x" -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Flash\Obj\stm32f10x_it.crf ..\..\User\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;95     */    
;;;96     void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;97     {
;;;98       /* 当总线异常时进入死循环 */
;;;99       while (1)
000002  e7fe              B        |L1.2|
;;;100      {
;;;101      }
;;;102    }
;;;103    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;139    */   
;;;140    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;141    {
;;;142    }
;;;143    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;63     */ 
;;;64     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L3.2|
;;;65     {
;;;66       /* 当硬件失效异常发生时进入死循环 */
;;;67       while (1)
000002  e7fe              B        |L3.2|
;;;68       {
;;;69       }
;;;70     }
;;;71     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;79     */   
;;;80     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;81     {
;;;82       /* 当内存管理异常发生时进入死循环 */
;;;83       while (1)
000002  e7fe              B        |L4.2|
;;;84       {
;;;85       }
;;;86     }
;;;87     
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;51     */  
;;;52     void NMI_Handler(void)
000000  4770              BX       lr
;;;53     {
;;;54     }
;;;55     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;151    */     
;;;152    void PendSV_Handler(void)
000000  4770              BX       lr
;;;153    {
;;;154    }
;;;155    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;127    */   
;;;128    void SVC_Handler(void)
000000  4770              BX       lr
;;;129    {
;;;130    }
;;;131    
                          ENDP


                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;15     
;;;16     void TIM3_IRQHandler(void)		    //2ms中断一次
000000  b510              PUSH     {r4,lr}
;;;17     {	
;;;18     	static u16 ms1=0;	//中断次数计数器
;;;19     	if(TIM3->SR & TIM_IT_Update)	
000002  4816              LDR      r0,|L8.92|
000004  8800              LDRH     r0,[r0,#0]
000006  f0100f01          TST      r0,#1
00000a  d026              BEQ      |L8.90|
;;;20     	{    
;;;21         TIM3->SR = ~TIM_FLAG_Update;//清除中断标志	
00000c  f64f70fe          MOV      r0,#0xfffe
000010  4912              LDR      r1,|L8.92|
000012  8008              STRH     r0,[r1,#0]
;;;22     		ms1++;
000014  4812              LDR      r0,|L8.96|
000016  8800              LDRH     r0,[r0,#0]  ; ms1
000018  f1000001          ADD      r0,r0,#1
00001c  4910              LDR      r1,|L8.96|
00001e  8008              STRH     r0,[r1,#0]
;;;23     		
;;;24     		RDAU();
000020  f7fffffe          BL       RDAU
;;;25      		Prepare_Data();
000024  f7fffffe          BL       Prepare_Data
;;;26      		AHRS_Update();
000028  f7fffffe          BL       AHRS_Update
;;;27     		Calculate_Target();
00002c  f7fffffe          BL       Calculate_Target
;;;28      		CONTROL(Target);
000030  480c              LDR      r0,|L8.100|
000032  c80f              LDM      r0,{r0-r3}
000034  f7fffffe          BL       CONTROL
;;;29         
;;;30     		if(ms1==4)
000038  4809              LDR      r0,|L8.96|
00003a  8800              LDRH     r0,[r0,#0]  ; ms1
00003c  2804              CMP      r0,#4
00003e  d10c              BNE      |L8.90|
;;;31     		{
;;;32     			ms1 = 0;
000040  2000              MOVS     r0,#0
000042  4907              LDR      r1,|L8.96|
000044  8008              STRH     r0,[r1,#0]
;;;33           if(flag.ARMED)			LED_Sailing(15);
000046  4808              LDR      r0,|L8.104|
000048  78c0              LDRB     r0,[r0,#3]  ; flag
00004a  b118              CBZ      r0,|L8.84|
00004c  200f              MOVS     r0,#0xf
00004e  f7fffffe          BL       LED_Sailing
000052  e002              B        |L8.90|
                  |L8.84|
;;;34           else                LED_Running(19);
000054  2013              MOVS     r0,#0x13
000056  f7fffffe          BL       LED_Running
                  |L8.90|
;;;35     		}		
;;;36     	}
;;;37     }
00005a  bd10              POP      {r4,pc}
;;;38     /*
                          ENDP

                  |L8.92|
                          DCD      0x40000410
                  |L8.96|
                          DCD      ms1
                  |L8.100|
                          DCD      Target
                  |L8.104|
                          DCD      flag

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=1

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;185    extern void usb_Istr(void);
;;;186    void USB_LP_CAN1_RX0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188    	usb_Istr();
000002  f7fffffe          BL       usb_Istr
;;;189    }
000006  bd10              POP      {r4,pc}
;;;190    
                          ENDP


                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;111    */   
;;;112    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L10.2|
;;;113    {
;;;114      /* 当用法异常时进入死循环 */
;;;115      while (1)
000002  e7fe              B        |L10.2|
;;;116      {
;;;117      }
;;;118    }
;;;119    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  ms1
000000  0000              DCW      0x0000
